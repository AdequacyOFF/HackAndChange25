# TESA_3.1
# TESA Frontend

**TESA** — это одностраничное фронтенд-приложение для анализа тональности текстов и работы с разметкой датасетов.  
Стек: **React + TypeScript + Vite**, современный UI в стиле _liquid glass + неон_, адаптированный под работу с ML-сервисом по HTTP.

> ВАЖНО: этот README описывает **только фронтенд** — структуру, логику и работу с настройками подключения к бэку (host/port) через интерфейс.

---

## Основные возможности

Фронтенд решает весь пользовательский сценарий “от CSV до отчёта по качеству модели”:

- Загрузка и анализ CSV-датасета с отзывами.
- Просмотр, фильтрация и ручная корректировка разметки.
- Выгрузка итоговых результатов в CSV.
- Подсчёт и визуализация метрик качества (macro-F1, метрики по классам, confusion matrix).
- Ручной анализ отдельных текстов (одиночные запросы).
- Лемматизация текста и NER (именованные сущности) в ручном режиме.
- Настройки:
  - тема (light/dark),
  - включение/выключение визуализаций,
  - гибкая настройка подключения к бэкенду (host/port) **через UI**, без перекомпиляции.

---

## Архитектура фронтенда

### Основные технологии

- **React 18+**
- **TypeScript**
- **Vite**
- CSS с кастомными CSS-переменными и темизацией (`tesa-theme-dark` / `tesa-theme-light`).

### Ключевые директории (логически)

- `src/context/`
  - `SettingsContext.tsx` — глобальные настройки приложения (тема, визуализации, backend host/port, labelMapping).
  - `AnalysisContext.tsx` — состояние пайплайна анализа: загруженный датасет, предсказания, фильтры, валидация, метрики.
- `src/components/`
  - `Sidebar.tsx` — общий сайдбар с фильтрами, загрузкой данных, экспортом и т.д.
  - `ManualAnalysisCard.tsx` — блок ручного анализа текста с чекбоксами лемматизации и NER.
  - различные UI-компоненты (таблицы, карточки, графики).
- `src/pages/`
  - `AnalyzePage.tsx` — вкладка “Анализ CSV”.
  - `ResultsPage.tsx` — вкладка “Результаты и разметка”.
  - `MetricsPage.tsx` — вкладка “Оценка качества”.
  - `VisualizationsPage.tsx` — вкладка с графиками.
  - `SettingsPage.tsx` — вкладка “Настройки”.
- `src/services/`
  - `sentimentApi.ts` — обёртки вокруг HTTP-запросов к API (`/predict`, `/csv`, `/lemmatize`, `/ner`).
  - `csvUtils.ts` — чтение/запись CSV на фронте.
  - `metrics.ts` — пересчёт метрик по локальным данным.
- `src/utils/`
  - `labelMapping.ts` — функции нормализации маппинга классов и преобразования кодов в “смысловые” метки.

---

## Интерфейс и страницы

### 1. Вкладка «Анализ» (Analyze)

**Цель:** загрузить CSV, отправить на анализ, получить предсказания.

Функциональность:

- Drag&drop-зона + кнопка «Выбрать файл…»:
  - при выборе файла дергается `loadCsvFile(file)` в `AnalysisContext`,
  - сохраняется краткая информация о датасете (имя файла, количество строк).
- Кнопка **«Запустить анализ»**:
  - вызывает `handleRunAnalysisClick` в `Sidebar`:
    - сбрасывает валидацию/метрики (`resetValidation()`),
    - запускает новый анализ (`runAnalysis()`).
  - кнопка заблокирована, если:
    - нет загруженного датасета,
    - анализ уже выполняется (loading = true).
- Статус пайплайна:
  - отображение статуса джоба (`обработка / готово / ошибка`),
  - количество строк.

Вся логика данных (что делать с файлом, как хранить строки, что такое `reviews`) инкапсулирована в `AnalysisContext`. Вкладка «Анализ» только дергает публичные методы контекста.

---

### 2. Вкладка «Результаты» (Results)

**Цель:** посмотреть предсказания, отфильтровать, поправить разметку, выгрузить финальный CSV.

Возможности:

- Таблица с результатами:
  - колонки вроде `ID`, `text`, предсказанный label, (опционально) `trueLabel` и `correctedLabel`,
  - визуальная подсветка тональности (0/1/2) бейджами.
- Фильтры в `Sidebar`:
  - **Тональность** — chip-кнопки для 0, 1, 2.
  - **Источник (src)** — выпадающий список по уникальным значениям `src`.
  - **Статус строки** — `Все / Только исправленные / Только без исправлений`.
  - **Сброс фильтров** — кнопка, возвращающая `filters` к дефолтному состоянию.
- Поиск:
  - режим `по тексту` / `по источнику`,
  - текстовое поле поиска, фильтрация по текущему режиму.
- Экспорт:
  - кнопка **«Скачать CSV»**,
  - чекбоксы `ID` и `text` (в одну строку) — что включать в exported CSV помимо `label`.

---

### 3. Вкладка «Оценка качества» (Metrics)

**Цель:** посчитать и визуализировать качество модели по эталонной разметке.

Функциональность:

- Загрузка валидационного CSV (drag&drop + кнопка):
  - анализируется структура файла,
  - сопоставляются `trueLabel` к текущим `reviews` (по `ID`/`text`/порядку),
  - состояние хранится в `AnalysisContext`, метрики пересчитываются.
- Блок **macro-F1**:
  - крупное число,
  - краткое объяснение, что оно означает,
  - вспомогательные “чипы” с количеством строк/совпадений.
- Отчёт в CSV:
  - кнопка **«Скачать отчёт (CSV)»**,
  - генерируется CSV с macro-F1, per-class metrics и confusion matrix.
- Confusion matrix:
  - включается/выключается отдельным флагом в настройках (`showConfusionMatrix`),
  - рендерится как сетка с подсветкой (heatmap-подобный градиент).

---

### 4. Вкладка «Визуализации» (Visualizations)

**Цель:** визуальный обзор датасета и поведения модели.

Типовой набор:

- распределение тональностей,
- разбивка по источникам `src`,
- bar-chart F1 по классам.

Каждый график завязан на соответствующий флаг в `settings.visualizations` и может быть выключен через UI.

---

### 5. Ручной анализ текста (ManualAnalysisCard)

Компонент, обычно располагается на странице аналитики/визуализаций.

Функциональность:

- Одно **textarea** для ввода текста отзыва.
- Кнопки:
  - **«Проанализировать»**:
    - отправляет текст на `/predict`,
    - при включённом чекбоксе **лемматизации** — дополнительно запрашивает `/lemmatize`,
    - при включённом чекбоксе **NER** — дополнительно запрашивает `/ner`,
    - результат записывается в локальный state `results` (последние 10 запросов).
  - **«Очистить»**:
    - очищает `text`,
    - очищает историю `results`.
- Чекбоксы в одной строке с кнопками:
  - **Лемматизация**:
    - если включён, в таблице для каждой строки показывается **отредактированный текст** (леmmatized), полученный от `/lemmatize`,
    - в противном случае — “сырой” исходный текст.
  - **NER**:
    - если включён, в таблице появляется **дополнительная колонка** со списком найденных сущностей (ответ `/ner`).
- Таблица последних запросов:
  - показывает до 10 последних анализов,
  - колонки:
    - № (обратный счёт: последний запрос — первый по номеру),
    - **Текст** (или лемматизированный текст, если включён чекбокс),
    - **Тональность** (бейдж + код),
    - (опционально, если NER включён) список сущностей.

Таким образом, ручной анализ можно использовать как интерактивный playground: включать/выключать лемматизацию и NER, видеть, как меняется текст и какие сущности извлекаются.

---

### 6. Вкладка «Настройки» (Settings)

**Цель:** управлять внешним видом, визуализациями, маппингом классов и главная фишка — подключением к бэкенду (host/port) через интерфейс.

Возможности:

1. **Тема интерфейса**

   - переключатель между **light** и **dark**.
   - при смене темы:
     - обновляется `settings.theme`,
     - на `<html>` ставится соответствующий класс:
       - `tesa-theme-light` или `tesa-theme-dark`,
     - CSS подтягивает нужную палитру/фон/тени.

2. **Визуализации**

   Чекбоксы для отдельных графиков:

   - `showSentimentDistribution`
   - `showSourceBreakdown`
   - `showConfusionMatrix`
   - `showF1BarChart`

3. **Маппинг классов (`labelMapping`)**

   - хранится в `settings.labelMapping` как объект:  
     `0 → 'negative'`, `1 → 'neutral'`, `2 → 'positive'`.
   - этот маппинг используется:
     - чтобы корректно интерпретировать коды `label`,
     - чтобы на всех страницах текстовые подписи соответствовали настоящему смыслу классов.

4. **Подключение к бэкенду (host/port)**

   Это ключевая особенность фронта:  
   **адрес бэкенда можно менять прямо из UI, без билда и без правки .env.**

   - в настройках есть поля:
     - `backend.host` — строка (например, `localhost`, `5.129.212.83`, доменное имя),
     - `backend.port` — число (например, `51000`).
   - при изменении этих полей:
     - вызывается `updateSettings({ backend: { host, port } })`,
     - состояние сохраняется в `localStorage` по ключу `tesa_settings_v1`,
     - все сервисы, использующие `buildBackendBaseUrl(settings)`, начинают ходить по **новому адресу**.

   #### Как это выглядит в коде

   В `SettingsContext.tsx`:

   ```ts
   export interface BackendSettings {
     host: string;
     port: number;
   }

   export interface AppSettings {
     ...
     backend: BackendSettings;
   }

   const defaultSettings: AppSettings = {
     ...
     backend: {
       host: '5.129.212.83', // дефолтный хост
       port: 51000,          // дефолтный порт
     },
   };

Функция сборки baseUrl:

```ts
export const buildBackendBaseUrl = (settings: AppSettings): string =>
  `http://${settings.backend.host}:${settings.backend.port}`;
```

Сохранение настроек:

```ts
const STORAGE_KEY = 'tesa_settings_v1';

useEffect(() => {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
  } catch {
    //
  }
}, [settings]);
```

Инициализация настроек (при загрузке страницы):

```ts
const [settings, setSettings] = useState<AppSettings>(() => {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return defaultSettings;
  const parsed = JSON.parse(raw) ?? {};

  return {
    ...defaultSettings,
    ...parsed,
    visualizations: {
      ...defaultSettings.visualizations,
      ...(parsed.visualizations ?? {}),
    },
    labelMapping: {
      ...defaultSettings.labelMapping,
      ...(parsed.labelMapping ?? {}),
    },
    backend: {
      ...defaultSettings.backend,
      ...(parsed.backend ?? {}),
    },
  } as AppSettings;
});
```

---

## Как фронт ходит на API

Все HTTP-запросы завязаны на `buildBackendBaseUrl(settings)`.

Пример из `sentimentApi.ts`:

```ts
import { buildBackendBaseUrl } from '../context/SettingsContext';

export async function analyzeText(settings: AppSettings, text: string) {
  const baseUrl = buildBackendBaseUrl(settings);
  const res = await fetch(`${baseUrl}/predict`, { ... });
  ...
}

export async function analyzeRows(settings: AppSettings, rows: RawInputRow[]) {
  const baseUrl = buildBackendBaseUrl(settings);
  // Загрузка CSV /csv или запросы к /predict — всё через baseUrl
  ...
}
```

То есть:

* изменил host/port в UI →
* `settings.backend` обновился →
* `buildBackendBaseUrl` возвращает уже новый URL →
* **все** вызовы (`/predict`, `/csv`, `/lemmatize`, `/ner`) идут на новый бэкенд.

Таким образом фронтенд не нужно пересобирать, если поменялся IP, порт или домен сервера с моделью.
---

## Фронтенд в docker контейнере (локально)

1. Сборка и запуск:

   находясь в _\TESA_3.1\tesa_:
   ```bash
   docker compose -f docker-compose.local.yaml up -d --build
   ```

2. Открыть в браузере:

   ```text
   http://localhost:3000
   ```

3. Перейти во вкладку **«Настройки»** и указать:

   * `host` — адрес бэкенда,
   * `port` — порт бэкенда.

4. Перейти во вкладку **«Анализ»**, загрузить CSV и запустить пайплайн.

---

## CI/CD Фронтенда

### Имеется настроенный для docker executor\`a gitlab runner\`a _.gitlab-ci.yml_
**Пайплайн реализован в 2 этапа:**
- build 
- deploy _(из docker-compose.yaml)_

### Общая информация:
- Расчитан на деплой за серверным nginx proxy для использования поддоменов
- Фронтенд находится на порте **3000**
- Конфигурация executor`a - Docker on another Docker (имеет доступ к серверному докер-демону)

### Конфигурация runner`a:
```
[[runners]]
  name = "Nexus Gitlab Runner"
  url = "https://gitlab.ad-off.digital"
  id = 1
  token = "---"
  token_obtained_at = 2025-10-10T20:53:21Z
  token_expires_at = 0001-01-01T00:00:00Z
  executor = "docker"
  [runners.cache]
    MaxUploadedArchiveSize = 0
    [runners.cache.s3]
    [runners.cache.gcs]
    [runners.cache.azure]
  [runners.docker]
    tls_verify = false
    image = "docker:28.5"
    privileged = false
    disable_entrypoint_overwrite = false
    oom_kill_disable = false
    disable_cache = false
    volumes = ["/var/run/docker.sock:/var/run/docker.sock", "/cache"]
    shm_size = 0
    network_mtu = 0
```
P.S. внимание стоит обратить на:
- volumes = ["/var/run/docker.sock:/var/run/docker.sock", "/cache"]
- privileged = false
---

## Фронтенд в docker контейнере (локально)

1. Сборка и запуск:

   находясь в _\TESA_3.1\tesa_:
   ```bash
   docker compose -f docker-compose.local.yaml up -d --build
   ```

2. Открыть в браузере:

   ```text
   http://localhost:3000
   ```

3. Перейти во вкладку **«Настройки»** и указать:

   * `host` — адрес бэкенда,
   * `port` — порт бэкенда.

4. Перейти во вкладку **«Анализ»**, загрузить CSV и запустить пайплайн.

---

## Запуск фронтенда локально

1. Установка зависимостей:

   ```bash
   npm install
   ```

2. Запуск дев-сервера:

   ```bash
   npm run dev
   ```

3. Открыть в браузере:

   ```text
   http://localhost:5173
   ```

4. Перейти во вкладку **«Настройки»** и указать:

   * `host` — адрес бэкенда,
   * `port` — порт бэкенда.

5. Перейти во вкладку **«Анализ»**, загрузить CSV и запустить пайплайн.

---

## Деплой фронтенда

Фронт — обычное SPA на Vite, поэтому можно деплоить куда угодно:

* **Netlify**, Vercel, GitHub Pages, любой S3 + CloudFront, свой nginx.

Базовые шаги:

1. Собрать прод-бандл:

   ```bash
   npm run build
   ```

2. Полученный `dist/` залить на выбранный хостинг (или использовать готовую интеграцию Netlify/Vercel).

3. После деплоя зайти на URL сайта → вкладка **«Настройки»** → прописать нужный `host`/`port` вашего бэкенда.

Если работает обратный прокси (`/api/*` → бэкенд), можно адаптировать фронтенд под относительные пути — архитектура это позволяет, достаточно скорректировать `buildBackendBaseUrl` или добавить переключатель стратегии.

---

## Резюме

Этот фронтенд:

* даёт полный UI-слой над сервисом анализа тональности (и сопутствующими NLP-фичами),
* умеет:

  * загружать и визуализировать датасеты,
  * править разметку,
  * считать и показывать метрики,
  * сохранять результаты,
  * работать в ручном режиме с лемматизацией и NER,
* и главное — **подключается к любому бэкенду через интерфейс**, без пересборки проекта:

  * host/port задаются в UI,
  * настройки живут в `localStorage`,
  * все запросы автоматически используют актуальный адрес.

Фактически, это универсальная фронтенд-оболочка для любых моделей тональности с похожим API.

```
::contentReference[oaicite:0]{index=0}
```
